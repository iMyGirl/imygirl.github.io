

- [牛客网_OJ在线编程常见输入输出练习](#牛客网_OJ在线编程常见输入输出练习)
- [leetcode](#leetcode)
    + [1.删除排序数组中的重复项](#1.删除排序数组中的重复项)
    - [2. 两数之和](#2-两数之和)
- [牛客网_剑指Offer](#牛客网_剑指offer)
    + [1.二维数组中的查找](#1-二维数组中的查找)
    + [2. 替换空格](#2-替换空格)
    + [3. 斐波那契数列](#3-斐波那契数列)
    + [4. 跳台阶](#4-跳台阶)
    + [5. 变态跳台阶](#5-变态跳台阶)
    + [6. 从尾到头打印链表](#6-从尾到头打印链表)
    + [7. 用两个栈实现队列](#7-用两个栈实现队列)
    + [8. 旋转数组的最小数字](#8-旋转数组的最小数字)
    + [9. 调整数组顺序使奇数位于偶数前面](9-调整数组顺序使奇数位于偶数前面)


# [牛客网_OJ在线编程常见输入输出练习]
<https://www.nowcoder.com/test/27976983/summary#question>
### a+b(1)
```
while True:
    try:
        data=input().split(' ')
        a = int(data[0])
        b = int(data[1])
        print(a+b)
    except:
        break
```
### a+b(2)
```
n = int(input())
for i in range(n):
    a,b = map(int, input().split())
    print(a+b)
```
### a+b(3)
```
while True:
    a,b = map(int, input().split())
    if a == 0 and b == 0:
        break
    print(a+b)
```
### a+b(4)
```
"""
while True:
    list_int = []
    list_int = map(int, input().split())
    if list_int[0] == 0 and len(list_int) == 1:
        break
    sum_list = 0
    for int_e in list_int:
        sum_list = sum_list + int_e 
    print(sum_list)
# 报错： Warning: cannot find your CPU L2 cache size in /proc/cpuinfo
#       Traceback (most recent call last):
#       File "a.pypy3", line 4, in <module>
#       if list_int[0] == 0 and len(list_int) == 1:
#       TypeError: 'map' object is not subscriptable (key 0)
"""
while True:
    list_int = list(map(int, input().split()))
    if list_int[0] == 0 and len(list_int) == 1:
        break
    sum_list = 0
    for i in range(list_int[0]):
        sum_list = sum_list + list_int[i+1] 
    print(sum_list)
```
### a+b(5)
```
t = int(input())
for i in range(t):
    list_int = list(map(int, input().split()))
    sum_list = 0
    for i in range(list_int[0]):
        sum_list = sum_list + list_int[i+1] 
    print(sum_list)
```
### a+b(6)
```
"""
# Traceback (most recent call last):
# File "/tmp/a.py3", line 2, in <module>
# list_int = list(map(int, input().split()))
# EOFError: EOF when reading a line

while True:
    list_int = list(map(int, input().split()))
    if list_int == '':
        break
    sum_list = 0
    for i in range(list_int[0]):
        sum_list = sum_list + list_int[i+1] 
    print(sum_list)
"""
while True:
    try:
        list_int = list(map(int, input().split()))
    #if list_int[0] == 0 and len(list_int) == 1:
     #   break
        sum_list = 0
        for i in range(list_int[0]):
            sum_list = sum_list + list_int[i+1] 
        print(sum_list)
    except:
        break
```
### a+b(7)
```
while (1):
    try:
        list_int = list(map(int,input().split()))
        sum_int = 0
        for i in range(len(list_int)):
            sum_int = sum_int + list_int[i]
        print(sum_int)
    except:
        break
```
### 字符排序（1）
```
n = int(input())
list_str = input().split()
list_str.sort()
print(' '.join(list_str))
```
### 字符串（2）
```
while True:
    try:
        list_str = input().split()
        list_str.sort()
        print(' '.join(list_str))
    except:
        break
```
### 字符串（3）
```
while True:
    try:
        list_str = input().split(',')
        list_str.sort()
        print(','.join(list_str))
    except:
        break
```

***
# leetcode
### 1.删除排序数组中的重复项
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。

示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        count = 0
        for i in range(1,len(nums)):
            if nums[i] != nums[count]:
                nums[count + 1] = nums[i]
                count += 1

        return count + 1
```
```
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        current = 0 # current默认赋值为0，这样就避免了special case (if not nums: return 0)

        for i in range(1, len(nums)): # 从index为1开始遍历数组，如果数组长度小于1，则会自动退出
            if nums[i] != nums[current]:
                nums[current + 1] = nums[i]
                current += 1

        return current + 1

作者：LucasWang474
链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/?discussion=9ZerB6
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 2. 两数之和
  
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]

示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

 

提示：

    2 <= nums.length <= 103
    -109 <= nums[i] <= 109
    -109 <= target <= 109
    只会存在一个有效答案


```
### 未调通
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        plot = []
        for i in range (1,len(nums)-1):
            for j in range(i+1,len(nums)):
                if nums[i] + nums[j] == target:
                    plot[0] = i
                    plot[1] = j
        return plot

```


# 牛客网_剑指Offer 
### 1. 二维数组中的查找
>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
  [1,2,8,9],
  [2,4,9,12],
  [4,7,10,13],
  [6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。


+ 暴力遍历  
时间复杂度: O(n^2)
```
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        array_len = len(array)
        for i in range(array_len):
            for j in range(len(array[i])):
                if array[i][j] == target:
                    return True
        return False
                
```
+ 遍历  
时间复杂度: O(n)
```
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        i = 0
        row_len = len(array)
        
        j = len(array[0])-1
        column_len = len(array)
        
        while i < row_len and j >= 0:
            
            
            value = array[i][j]
            if value < target:
                i += 1
            if value > target:
                j -= 1
            if value == target:
                return True
        return False
        # 78ms
```
### 2. 替换空格  
>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return string字符串
#
class Solution:
    def replaceSpace(self , s ):
        # write code here
        return s.replace(' ', '%20')
# 22ms
```
```
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param s string字符串 
# @return string字符串
#
class Solution:
    def replaceSpace(self , s ):
        # write code here
        str_replace = []
        for i in range(len(s)):
            if s[i] == ' ':
                str_replace.append('%20')
            else:
                str_replace.append(s[i])
        return ''.join(str_replace) 
# 24ms
```
### 3. 斐波那契数列
>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n≤39



递归 ，时间复杂度：O(2^n)
（超时）
```
# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here 
        
        # n=0, f(0)=0
        if n == 0:
            return 0
        # n=1, f(1)=1
        if n == 1:
            return 1
        # if n>1 f(n) = f(n-1) + f(n-2)
        if n>1 :
            number = self.Fibonacci(n-1) + self.Fibonacci(n-2)
            return number
        return None
 ```  
 时间复杂度： O(n)
 ```
 # -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here 
        if n == 0 :
            return 0
        if n == 1 :
            return 1
        a = 1
        b = 0
        if n > 1 :
            for i in range(n-1):
                h = a + b
                b = a
                a = h 
                
        return h 
 #18ms
 ```
 P.S.
 ```
 # -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here 
        
        # n=0, f(0)=0
        if n == 0:
            return 0
        # n=1, f(1)=1
        if n == 1:
            return 1
        # if n>1 f(n) = f(n-1) + f(n-2)
        if n>1 :
            number = self.Fibonacci(n-1) + self.Fibonacci(n-2)
            return number

        return None

if __name__ == "__main__":
    s = Solution()
    print(s.Fibonacci(4))
 ```
### 4. 跳台阶
>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
```
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        # write code here
        # number = 1 ,    1  
        # number = 1 ,    2
        # number = 3 ,    3
        # number = 4 ,    5
        # 通过找规律发现， f(n) = f(n-1) + f(n-2), 当n>2
        # 当n=1,number = 1
        # 当n=2, number = 2
        if  number < 1:
            return 0
        if number == 1:
            return 1
        if number == 2:
            return 2
        ret = 0
        a = 1
        b = 2
        for i in range(3,number+1):
            ret = a + b 
             
            a = b 
            
            b = ret 
        return ret  
```
### 5. 变态跳台阶
>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```
# -*- coding:utf-8 -*-
# 18ms
class Solution:
    def jumpFloorII(self, number):
        # write code here
        # number = 1, 1
        # number = 2, 1
        # number = 3, 4
        # number = 4, 8
        # number = n, 2^(n-1)
        return pow(2, number - 1)
```
贪心算法

```
# -*- coding:utf-8 -*-
# 19ms
class Solution:
    def jumpFloorII(self, number):
        # write code here
        # f(n) = f(n-1) + f(n-2) + ... + f(1)
        # f(n-1) = f(n-2) + f(n-3) + ... + f(1)
        # f(n) = 2 f(n-1)
        if number == 1:
            return 1
        #ret = 1
        a = 1
        for i in range(0, number-1):
            ret = 2 * a
            a = ret 
        return ret
            
```
### 6. 从尾到头打印链表
>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
```
#19ms
# -*- coding:utf-8 -*-

# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        ret = []
        pTmp = listNode
        while pTmp:
            ret.insert(0, pTmp.val) # 头插法？
            pTmp = pTmp.next
        return ret
            

```
P.S.
```
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def printChain(node):
    while node:
        print(node.val)
        node = node.next


if __name__ == '__main__':
#    1 -> 2 -> 3 
   l1 = ListNode(1)
   l2 = ListNode(2)
   l3 = ListNode(3)
   l1.next = l2
   l2.next = l3
   l3.next = None
   printChain(l1)
```
### 7. 用两个栈实现队列
>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```
#15ms
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.acceptStack = []
        self.outputStack = []
    def push(self, node):
        # write code here
        self.acceptStack.append(node)
    def pop(self):
        # return xx
        if self.outputStack == []:
            #self.outputStack.
            while self.acceptStack:
                self.outputStack.append(self.acceptStack.pop())
        if self.outputStack != []:
            return self.outputStack.pop()
        else:
            return None
```

### 8. 旋转数组的最小数字
>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

O(n)
```
# 203ms
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        minNum = 0
        for i in range(0 , len(rotateArray)):
            minNum = minNum if minNum < rotateArray[i] and minNum !=0 else rotateArray[i]
        return minNum
```
最小二分法

O(log(n))
```
#531ms
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        # 最小值 一定比前面的小
        # 二分查找数据，找左右的方法： 右边大于中值， 就说明最小值在左边
        if not rotateArray:
            return 0
        left = 0
        right = len(rotateArray) - 1
        while left <= right:
            mid = (left + right) >> 1
            if rotateArray[mid] < rotateArray[mid - 1]:
                return rotateArray[mid]
            elif rotateArray[mid] < rotateArray[right]:
                right = mid - 1
            else:
                left = mid +1
        return 0
```
### 9. 调整数组顺序使奇数位于偶数前面
>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
```
#50ms
# 时间复杂度O(n)
# 空间复杂度O(n)
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param array int整型一维数组 
# @return int整型一维数组
#
class Solution:
    def reOrderArray(self , array ):
        # write code here
        list_name = []
        list_array = []
        list_array_o = []
        for i in range(0,len(array)):
            if array[i]%2 == 1:
                list_array.append(array[i])
            else:
                list_array_o.append(array[i])
        for j in range(0, len(list_array)):
            list_name.append(list_array[j])
        for k in range(0, len(list_array_o)):
            list_name.append(list_array_o[k])
        return list_name
```





# 问题汇总
